Objetivo:
Evoluir meu projeto Next.js (App Router) para um or√ßamentador de obras com:

Gera√ß√£o de BOM (lista de materiais) a partir de √°rea, tipo, padr√£o.

Lista Local (por CEP) com lojas pr√≥ximas e menor custo entregue (pre√ßo + frete).

Lista Online (e-commerce) com menor custo total (pre√ßo + frete + prazo).

Otimiza√ß√£o para sugerir cesta √≥tima (poss√≠vel divis√£o entre fornecedores).

Tudo isso sem alterar o restante do c√≥digo/UX j√° existente: apenas acoplar nos pontos indicados.

Regras e Constrangimentos (N√ÉO NEGOCIAR)

N√£o alterar a UI atual nem quebrar props; o componente OrcamentoQuanticoPage com "use client" deve permanecer igual, apenas conectar novas chamadas/props/sections.

Sem chaves no client. Toda integra√ß√£o externa s√≥ via rotas server em app/api/**.

C√≥digo em TypeScript estrito, tipando DTOs de request/response.

Adicionar tratamento de erro, timeouts ~(10s), rate limit leve (ex.: token bucket in-memory) e cache (Edge/Memory) para requisi√ß√µes repetidas.

Usar feature flags por env (ex.: USE_PLACES=true/false) para ligar/desligar provedores sem quebrar.

Commits at√¥micos e mensagens claras. Nenhum c√≥digo morto. Linters passam.

1) Vari√°veis de Ambiente (criar e tipar)

Criar .env.local.example e validar em env.d.ts:

GOOGLE_MAPS_KEY=
MELI_TOKEN=
CORREIOS_TOKEN=
SERP_API_KEY=          # opcional (Google Shopping via SerpAPI)
OVERPASS_URL=https://overpass-api.de/api/interpreter
USE_PLACES=true        # se false, usa OSM (Overpass) para lojas locais
USE_SERP=false         # se true, habilita Google Shopping via SerpAPI


Garanta que nunca exportamos essas chaves ao client.

2) Pastas e Arquivos a ADICIONAR (sem mexer no resto)
/app/api/geo/nearby/route.ts            # Google Places ou fallback OSM
/app/api/open/local/overpass/route.ts   # Overpass para OSM
/app/api/preco/frete/route.ts           # Correios Pre√ßo & Prazo (ou agregador)
/app/api/online/meli/route.ts           # Mercado Livre (busca/pre√ßos/envio)
/app/api/orcamento/cotacao/route.ts     # Orquestrador: recebe BOM ‚ûú cota√ß√µes ‚ûú otimiza√ß√£o

/src/lib/cotacao/bom.ts                 # gerador de BOM por tipo/padr√£o/√°rea
/src/lib/cotacao/providers.ts           # fetchers tipados para cada provedor
/src/lib/cotacao/optimizer.ts           # min-cost para cesta √≥tima
/src/lib/cotacao/normalizers.ts         # normaliza√ß√£o de unidades (kg, m¬≥, saco)
/src/lib/cotacao/types.ts               # DTOs e tipos fortes
/src/lib/cotacao/cache.ts               # memo/cache simples com TTL
/src/lib/cotacao/rateLimit.ts           # rate limit leve
/data/sinapi/sinapi_basico.json         # composi√ß√µes base (mock inicial)


IMPORTANTE: N√£o modifique arquivos existentes de UI. Se necess√°rio, apenas acrescente se√ß√µes no Tab ‚Äúresultados‚Äù: ‚ÄúLista Local‚Äù e ‚ÄúLista Online‚Äù.

3) Tipos/DTOs (criar /src/lib/cotacao/types.ts)

Tipar BOMItem (sku, nome, unidade, quantidade), FornecedorItem (pre√ßo, frete, prazo, url), Proposta (Local/Online), CotacaoRequest (√°rea, tipo, padr√£o, CEP), CotacaoResponse (duas listas + cesta √≥tima + m√©tricas).

Reutilizar enums/aliases j√° existentes (ex.: RegionalData se houver).

Definir Money = { value: number; currency: 'BRL' }, tudo em centavos.

4) Gerador de BOM ( /src/lib/cotacao/bom.ts )

Implementar buildBOM({ area, tipo, padrao }): BOMItem[] usando /data/sinapi/sinapi_basico.json (mock) para composi√ß√µes por m¬≤.

Regra simples: multiplicar coeficientes por area; aplicar fator por padrao (popular/medio/alto/luxo).

Prever equival√™ncias de SKU (ex.: cimento 50kg vs 25kg) em normalizers.ts com l√≥gica de convers√£o.

5) Providers ( /src/lib/cotacao/providers.ts )

Local:

Se USE_PLACES=true, usar rota /api/geo/nearby para listar lojas (hardware/building materials) num raio (10‚Äì20 km do CEP).

Se USE_PLACES=false, usar /api/open/local/overpass.

Para pre√ßo local, tentar site da loja (quando dispon√≠vel) ou, se USE_SERP=true, chamar SerpAPI (Shopping Nearby) pela rota server (opcional).

Frete/prazo: /api/preco/frete (Correios ou transportadora simulada), conforme peso/dimens√µes do item.

Online:

/api/online/meli (Mercado Livre). Considere shipping para o CEP (custo e prazo).

Retornar lista por item com as 3‚Äì5 melhores ofertas (pre√ßo, frete, prazo, vendedor, rating).

Todos os providers devem:

Aceitar AbortSignal (timeout).

Normalizar resultado em FornecedorItem.

NUNCA vazar chaves ao client.

Usar cache.get/set com TTL (ex.: 15 min).

6) Otimizador ( /src/lib/cotacao/optimizer.ts )

Fun√ß√£o: pickCheapestBasket(bom: BOMItem[], ofertas: MapaDeOfertasPorSKU, constraints).

Objetivo: minimizar custo total entregue = ‚àë(pre√ßo item + frete item ou frete por loja) + penalidades (prazo > X dias, loja com baixa reputa√ß√£o).

Heur√≠stica pr√°tica:

Para cada item, selecione top-3 ofertas por (pre√ßo + frete).

Monte cestas por agrupamento de loja e escolha a melhor.

Se empate, preferir melhor prazo e melhor rating.

Retorne: cesta √≥tima + alternativas (2¬™/3¬™ melhor).

7) Rotas Server (implementar)
/app/api/geo/nearby/route.ts

POST { lat, lng, radiusMeters, keyword }

Se USE_PLACES=true: Google Places Nearby/SearchText (v1) com X-Goog-FieldMask.

Caso contr√°rio, proxy para /api/open/local/overpass.

Timeout 10s, cache 15min, rate limit.

/app/api/open/local/overpass/route.ts

POST { lat, lng, radius }

Executa query Overpass para shop=building_materials e shop=hardware.

Normaliza para estrutura comum de loja.

/app/api/preco/frete/route.ts

POST { cepOrigem, cepDestino, peso, dimensoes, servico }

Integra com Correios (ou retorne mock configur√°vel se CORREIOS_TOKEN faltar).

Retorna { valorFrete, prazoDias, servico }.

/app/api/online/meli/route.ts

POST { query, zip }

Usa token OAuth MELI_TOKEN.

Retorna itens com price, shipping.cost, shipping.time, permalink, seller.reputation.

/app/api/orcamento/cotacao/route.ts (ORQUESTRADOR)

POST { area, tipo, padrao, cep }

Passos:

buildBOM ‚Üí BOMItem[].

Geocode/CEP ‚Üí lat/lng.

Providers: coletar Local e Online por item (com cache).

Calcular frete total (policy: por-loja ou por-item).

optimizer ‚Üí cesta √≥tima + alternativas.

Retornar CotacaoResponse com:

bom, listaLocal[], listaOnline[], cestaOtima, metrica: {custoTotal, prazo, lojasUsadas}, debug?.

8) Integra√ß√£o no Client (sem quebrar a UI)

No Tab ‚Äúresultados‚Äù, ADICIONAR (no final) dois blocos abaixo do resultado atual:

Lista Local (por CEP): tabela com SKU, Fornecedor, Pre√ßo, Frete, Prazo, Link.

Lista Online: mesma estrutura.

Cesta √ìtima: resumo consolidado (total, economia vs m√©dia, lojas, prazo).

N√£o remova nada do que j√° existe.

Adicionar um bot√£o: ‚Äúüîé Cotar Materiais (Local & Online)‚Äù que faz POST /api/orcamento/cotacao com { area, tipo, padrao, cep } e, ao concluir, rende os tr√™s blocos acima.

Tratar loading/erro com toasts leves. N√£o bloquear o seu fluxo qu√¢ntico.

9) Persist√™ncia (Firebase)

Quando j√° salvamos quantum-calculations, agora salvar tamb√©m:

{
  ...,
  cotacoes: {
    bom,
    listaLocal,
    listaOnline,
    cestaOtima,
    generatedAt: serverTimestamp()
  }
}


N√£o alterar a estrutura anterior; apenas acrescentar este campo.

10) Testes R√°pidos (pelo menos)

Unit: bom.ts (regras por √°rea/padr√£o), normalizers.ts (convers√µes), optimizer.ts (ex.: 3 itens √ó 2 lojas).

E2E leve: rota /api/orcamento/cotacao com USE_PLACES=false e mocks, garantindo resposta consistente.

11) Observabilidade

Logger pequeno (console + flag DEBUG_COTACAO=true) no server.

Logar tempo de cada provedor e cache hits.

N√£o logar tokens nem dados sens√≠veis.

12) Entreg√°veis (Commits sugeridos)

chore(env): add env schema and examples for providers

feat(bom): basic SINAPI-like compositions and BOM generator

feat(providers): local (places/osm), online (meli), freight (correios)

feat(optimizer): cheapest basket with constraints

feat(api): orchestrator /api/orcamento/cotacao

feat(ui): add Local/Online/Cesta sections (non-breaking)

test(core): unit tests for bom/optimizer/normalizers

docs(readme): how to set keys and run

Entregar PR final passando build, lint e testes. N√£o remover nada existente.